// -*- C++ -*-
#ifndef _MY_MAP_H
#define _MY_MAP_H 1

#include<memory>
#include<utility>
#include<functional>
#include"std.h"

namespace stl_with_memory_pool{

template<class T,class U> concept __rv_as=std::is_constructible_v<U,T&&>;
template<class T> concept __trans=requires{typename T::is_transparent;};

template<class Key, class T, class Compare=std::less<Key>,
	class Allocator=allocator<std::pair<const Key, T>>
> struct map{
	using key_type=Key;
	using mapped_type=T;
	using value_type=std::pair<const Key, T>;
	using size_type=uint32_t;
	using difference_type=int;
	using key_compare=Compare;
	using allocator_type=Allocator;
	using reference=value_type&;
	using const_reference=const value_type&;
	using pointer=typename std::allocator_traits<Allocator>::pointer;
	using const_pointer=typename std::allocator_traits<Allocator>::const_pointer;

	struct iterator;
	struct const_iterator;

	using reverse_iterator=std::reverse_iterator<iterator>;
	using const_reverse_iterator=std::reverse_iterator<const_iterator>;

struct value_compare{
friend struct map;
protected:
	Compare comp;
	value_compare(Compare c):comp(c){}
public:
	bool operator()(const value_type& lhs, const value_type& rhs)const{
		return comp(lhs.first, rhs.first);
	}
};

key_compare key_comp()const{return _Cmp;}
value_compare value_comp()const{return value_compare(_Cmp);}

private:

bool _Lt(const Key& a,const Key& b)const{return _Cmp(a,b);}
bool _Eq(const Key& a,const Key& b)const{return !_Lt(a,b) && !_Lt(b,a);}
template<class X,class Y,__trans=Compare>
bool _Lt(const X& a,const Y& b)const{return a<b;}
template<class X,class Y,__trans=Compare>
bool _Eq(const X& a,const Y& b)const{return !(a<b) && !(b<a);}

using _Vl=std::pair<Key,T>;

static constexpr int B=32;
struct _Node{
	short n,fa_id;
	alignas(_Vl) char _dat[2*B*sizeof(_Vl)]; //bypass initialization
	_Node **ch,*fa;
	
	constexpr _Vl* dat(){return (_Vl*)_dat;}
	constexpr const _Vl* dat()const{return (const _Vl*)_dat;}
	_Node(const _Node& rhs):n(rhs.n),fa_id(rhs.fa_id),ch(rhs.ch),fa(rhs.fa){
		for(short i=0;i<rhs.n;i++)
			std::construct_at(dat()+i,rhs.dat()[i]);
	}
	_Node& operator=(const _Node&)=delete;
};
_Node* _Root;size_type _Sz;Compare _Cmp;

using _Node_alloc=typename std::allocator_traits<Allocator>::template rebind_alloc<_Node>;
using _Ptr_alloc=typename std::allocator_traits<Allocator>::template rebind_alloc<_Node*>;
using _T_alloc=typename std::allocator_traits<Allocator>::template rebind_alloc<T>;

constexpr static bool _Leaf(const _Node& x){return !x.ch;}

iterator _Make_it(_Node*p,short k){return iterator(_Root,p,k);}
const_iterator _Make_cit(const _Node*p,short k)const{return const_iterator(_Root,p,k);}

static const _Node* _Find_first(const _Node* p){ //can return nullptr
	while(!_Leaf(*p))p=p->ch[0];
	return p->n?p:nullptr;
}
static const _Node* _Find_last(const _Node* p){ //can return nullptr
	while(!_Leaf(*p))p=p->ch[p->n];
	return p->n?p:nullptr;
}

template<class K> iterator _Find(const K& x){
	_Node* p=_Root;
	for(short i;;p=p->ch[i]){
		for(i=0;i<p->n && _Lt(p->dat()[i].first,x);i++);
		if(i<p->n && !_Lt(x,p->dat()[i].first))return _Make_it(p,i);
		if(_Leaf(*p))return _Make_it(nullptr,0);
	}
}
template<class K> const_iterator _Find(const K& x)const{
	const _Node* p=_Root;
	for(short i;;p=p->ch[i]){
		for(i=0;i<p->n && _Lt(p->dat()[i].first,x);i++);
		if(i<p->n && !_Lt(x,p->dat()[i].first))return _Make_cit(p,i);
		if(_Leaf(*p))return _Make_cit(nullptr,0);
	}
}

_Node* _New_node(short n,short id,_Node* fa){
	_Node* p=_Node_alloc().allocate(1);
	p->n=n;p->fa_id=id;p->fa=fa;p->ch=nullptr;
	return p;
}

template<class K> std::pair<iterator,bool> _Find_or_insert(K x){
	_Node* p=_Root;short i;
	for(;;p=p->ch[i]){
		for(i=0;i<p->n && _Lt(p->dat()[i].first,x);i++);
		if(i<p->n && !_Lt(x,p->dat()[i].first))return {_Make_it(p,i),false};
		if(_Leaf(*p))break;
	}
	
	for(short j=p->n-1;j>=i;j--){
		if(j+1<p->n)p->dat()[j+1]=std::move(p->dat()[j]);
		else std::construct_at(p->dat()+j+1,std::move(p->dat()[j]));
	}
	if(i<p->n)p->dat()[i].first=std::move(x);
	else std::construct_at(std::addressof(p->dat()[i].first),std::move(x));
	p->n++;_Sz++;
	iterator ret(_Root,p,i);bool fix=false;
	
	auto split=[&]{
		_Node* f=p->fa;short id=p->fa_id;
		for(short j=f->n;j>id;j--){
			f->ch[j+1]=f->ch[j],f->ch[j+1]->fa_id++;
			if(j<f->n)f->dat()[j]=std::move(f->dat()[j-1]);
			else std::construct_at(f->dat()+j,std::move(f->dat()[j-1]));
		}
		constexpr short l=B,r=B-1;
		if(id<f->n)f->dat()[id]=std::move(p->dat()[l]);
		else std::construct_at(f->dat()+id,std::move(p->dat()[l]));
		p->dat()[l].~_Vl();f->n++;
		_Node* q=_New_node(r,id+1,f);
		for(short j=l+1;j<2*B;j++)
			std::construct_at(q->dat()+j-l-1,std::move(p->dat()[j])),
			p->dat()[j].~_Vl();
		if(p->ch){
			q->ch=_Ptr_alloc().allocate(2*B+1);
			for(short j=l+1;j<=2*B;j++)
				q->ch[j-l-1]=p->ch[j],q->ch[j-l-1]->fa=q,
				q->ch[j-l-1]->fa_id-=l+1;
		}
		if(!fix){
			if(i==l)ret=_Make_it(f,id),i=id;
			else{
				fix=true;
				if(i>l)ret=_Make_it(q,i-l-1);
			}
		}
		p->n=l;f->ch[id+1]=q;
	};
	
	for(;p!=_Root && p->n==2*B;p=p->fa)split();
	if(p==_Root && p->n==2*B){
		_Root=_New_node(0,0,nullptr);
		p->fa=_Root;p->fa_id=0;
		_Root->ch=_Ptr_alloc().allocate(2*B+1);
		_Root->ch[0]=p;split();
	}
	return {ret,true};
}

void _Copy_from(_Node* p,const _Node* other){
	if(_Leaf(*other))return;
	p->ch=_Ptr_alloc().allocate(2*B+1);
	for(short i=0;i<=p->n;i++){
		p->ch[i]=_Node_alloc().allocate(1);
		std::construct_at(p->ch[i],*other->ch[i]);
		p->ch[i]->fa=p;
		_Copy_from(p->ch[i],other->ch[i]);
	}
}

void _Del_node(_Node* p){
	for(short i=0;i<p->n;i++)
		p->dat()[i].~_Vl();
	if(!_Leaf(*p))
		for(short i=0;i<=p->n;i++)
			_Del_node(p->ch[i]);
}

public:
struct iterator{
friend struct const_iterator;
using difference_type=map::difference_type;
using value_type=map::value_type;
private:
	const _Node*rt; _Node*p; short k;
public:
	iterator(const _Node*rt=nullptr,_Node*p=nullptr,short k=0):rt(rt),p(p),k(k){}
	bool operator==(const auto&rhs)const{
		if(p==rhs.p && p==nullptr)return true;
		return p==rhs.p && k==rhs.k;
	}
	value_type& operator*()const{return ((value_type*)p->dat())[k];}
	value_type* operator->()const{return (value_type*)p->dat()+k;}
	iterator& operator++(){
		if(!_Leaf(*p))p=(_Node*)_Find_first(p->ch[k+1]),k=0;
		else{
			if(k+1<p->n)++k;else{
				while(p!=rt && p->fa_id==p->fa->n)p=p->fa;
				if(p==rt)p=nullptr,k=0;
				else k=p->fa_id,p=p->fa;
			}
		}
		return *this;
	}
	iterator operator++(int){
		auto res=*this;++*this;
		return res;
	}
	iterator& operator--(){
		if(p==nullptr)p=(_Node*)_Find_last(rt),k=p->n-1;
		else if(!_Leaf(*p))p=(_Node*)_Find_last(p->ch[k]),k=p->n-1;
		else if(k)--k;
		else{
			while(p!=rt && !p->fa_id)p=p->fa;
			if(p==rt)p=nullptr,k=0;
			else k=p->fa_id-1,p=p->fa;
		}
		return *this;
	}
	iterator operator--(int){
		auto res=*this;--*this;
		return res;
	}
};

struct const_iterator{
friend struct iterator;
using difference_type=map::difference_type;
using value_type=const map::value_type;
private:
	const _Node*rt,*p; short k;
public:
	const_iterator(const _Node*rt=nullptr,const _Node*p=nullptr,short k=0)
		:rt(rt),p(p),k(k){}
	const_iterator(const iterator&rhs):rt(rhs.rt),p(rhs.p),k(rhs.k){}
	bool operator==(const auto&rhs)const{
		if(p==rhs.p && p==nullptr)return true;
		return p==rhs.p && k==rhs.k;
	}
	value_type& operator*()const{return ((value_type*)p->dat())[k];}
	value_type* operator->()const{return (value_type*)p->dat()+k;}
	const_iterator& operator++(){
		if(!_Leaf(*p))p=_Find_first(p->ch[k+1]),k=0;
		else{
			if(k+1<p->n)++k;else{
				while(p!=rt && p->fa_id==p->fa->n)p=p->fa;
				if(p==rt)p=nullptr,k=0;
				else k=p->fa_id,p=p->fa;
			}
		}
		return *this;
	}
	const_iterator operator++(int){
		auto res=*this;++*this;
		return res;
	}
	const_iterator& operator--(){
		if(p==nullptr)p=_Find_last(rt),k=p->n-1;
		else if(!_Leaf(*p))p=_Find_last(p->ch[k]),k=p->n-1;
		else if(k)--k;
		else{
			while(p!=rt && !p->fa_id)p=p->fa;
			if(p==rt)p=nullptr,k=0;
			else k=p->fa_id-1,p=p->fa;
		}
		return *this;
	}
	const_iterator operator--(int){
		auto res=*this;--*this;
		return res;
	}
};

size_type size()const{return _Sz;}
size_type max_size()const{return 1e9;}
[[nodiscard]] bool empty()const{return !_Sz;}

iterator begin(){return _Make_it((_Node*)_Find_first(_Root),0);}
const_iterator begin()const{return _Make_cit(_Find_first(_Root),0);}
const_iterator cbegin()const{return _Make_cit(_Find_first(_Root),0);}
iterator end(){return _Make_it(nullptr,0);}
const_iterator end()const{return _Make_cit(nullptr,0);}
const_iterator cend()const{return _Make_cit(nullptr,0);}
reverse_iterator rbegin(){return reverse_iterator{end()};}
const_reverse_iterator rbegin()const{return const_reverse_iterator{end()};}
const_reverse_iterator crbegin()const{return const_reverse_iterator{end()};}
reverse_iterator rend(){return reverse_iterator{begin()};}
const_reverse_iterator rend()const{return const_reverse_iterator{begin()};}
const_reverse_iterator crend()const{return const_reverse_iterator{begin()};}

map():_Sz(0),_Cmp(Compare()){
	_Root=_New_node(0,0,nullptr);
}
explicit map(const Compare& comp, const Allocator& =Allocator()):_Sz(0),_Cmp(comp){
	_Root=_New_node(0,0,nullptr);
}
explicit map(const Allocator&):_Sz(0),_Cmp(Compare()){
	_Root=_New_node(0,0,nullptr);
}
template<std::input_iterator InputIt>
map(InputIt first,InputIt last,const Compare& comp=Compare(),const Allocator& =Allocator()):_Sz(0),_Cmp(comp){
	_Root=_New_node(0,0,nullptr);
	while(first!=last)insert(*first++);
}
template<std::input_iterator InputIt>
map(InputIt first,InputIt last,const Allocator&):_Sz(0),_Cmp(Compare()){
	_Root=_New_node(0,0,nullptr);
	while(first!=last)insert(*first++);
}
map(const map& other):_Sz(other._Sz),_Cmp(other._Cmp){
	_Root=_Node_alloc().allocate(1);
	std::construct_at(_Root,*other._Root);
	_Copy_from(_Root,other._Root);
}
map(const map& other,const Allocator&):_Sz(other._Sz),_Cmp(other._Cmp){
	_Root=_Node_alloc().allocate(1);
	std::construct_at(_Root,*other._Root);
	_Copy_from(_Root,other._Root);
}
map(map&& other)noexcept:_Root(other._Root),_Sz(other._Sz),_Cmp(other._Cmp){
	other._Sz=0;other._Root=_New_node(0,0,nullptr);
}
map(map&& other,const Allocator&)noexcept:_Root(other._Root),_Sz(other._Sz),_Cmp(other._Cmp){
	other._Sz=0;other._Root=_New_node(0,0,nullptr);
}
map(std::initializer_list<value_type> init,
	const Compare& comp=Compare(),
	const Allocator& =Allocator()){
	std::construct_at(this,init.begin(),init.end(),comp);
}
map(std::initializer_list<value_type> init,
	const Allocator& alloc){
	std::construct_at(this,init.begin(),init.end(),alloc);
}

~map(){_Del_node(_Root);}

iterator find(const Key& key){return _Find(key);}
const_iterator find(const Key& key)const{return _Find(key);}
template<class K, __trans=Compare>
	iterator find(const K& x){return _Find(x);}
template<class K, __trans=Compare>
	const_iterator find(const K& x)const{return _Find(x);}

T& at(const Key& key){
	iterator k=find(key);
	if(k.p)return k->second;
	throw std::out_of_range("Debug your code and then use operator[] instead");
}
const T& at(const Key& key)const{
	const_iterator k=find(key);
	if(k.p)return k->second;
	throw std::out_of_range("Debug your code and then use operator[] instead");
}

std::pair<iterator,bool> insert(const value_type& value){
	auto ret=_Find_or_insert<const Key&>(value.first);
	if(ret.second)std::construct_at(std::addressof(ret.first->second),value.second);
	return ret;
}
std::pair<iterator,bool> insert(value_type&& value){
	auto ret=_Find_or_insert<const Key&&>(std::move(value.first));
	if(ret.second)std::construct_at(std::addressof(ret.first->second),std::move(value.second));
	return ret;
}
template<__rv_as<value_type> P>
std::pair<iterator,bool> insert(P&& value){
	auto ret=_Find_or_insert<decltype(value.first)&&>(std::move(value.first));
	if(ret.second)std::construct_at(std::addressof(ret.first->second),std::move(value.second));
	return ret;
}
template<std::input_iterator InputIt>
void insert(InputIt first,InputIt last){
	while(first!=last)insert(*first++);
}
void insert(std::initializer_list<value_type> ilist){
	insert(ilist.begin(),ilist.end());
}

template<class M>
std::pair<iterator,bool> insert_or_assign(const key_type& k,M&& obj){
	auto ret=_Find_or_insert<const Key&>(k);
	if(!ret.second)ret.first->second=std::move(obj);
	else std::construct_at(std::addressof(ret.first->second),std::move(obj));
	return ret;
}
template<class M>
std::pair<iterator,bool> insert_or_assign(key_type&& k,M&& obj){
	auto ret=_Find_or_insert<Key&&>(std::move(k));
	if(!ret.second)ret.first->second=std::move(obj);
	else std::construct_at(std::addressof(ret.first->second),std::move(obj));
	return ret;
}

T& operator[](const Key& key){
	auto r=_Find_or_insert<const Key&>(key);
	if(r.second){
		auto a=_T_alloc();
		std::allocator_traits<_T_alloc>::construct(a,std::addressof(r.first->second));
	}
	return r.first->second;
}
T& operator[](Key&& key){
	auto r=_Find_or_insert<Key&&>(std::move(key));
	if(r.second){
		auto a=_T_alloc();
		std::allocator_traits<_T_alloc>::construct(a,std::addressof(r.first->second));
	}
	return r.first->second;
}

iterator lower_bound(const Key& key){
	_Node *p=_Root;auto now=_Make_it(nullptr,0);
	for(short i;;p=p->ch[i]){
		for(i=0;i<p->n && _Lt(p->dat()[i].first,key);i++);
		if(i<p->n)now=_Make_it(p,i);
		if(_Leaf(*p))return now;
	}
}
const_iterator lower_bound(const Key& key)const{
	const _Node *p=_Root;auto now=_Make_cit(nullptr,0);
	for(short i;;p=p->ch[i]){
		for(i=0;i<p->n && _Lt(p->dat()[i].first,key);i++);
		if(i<p->n)now=_Make_cit(p,i);
		if(_Leaf(*p))return now;
	}
}
template<class K,__trans=Compare>
iterator lower_bound(const K& key){
	_Node *p=_Root;auto now=_Make_it(nullptr,0);
	for(short i;;p=p->ch[i]){
		for(i=0;i<p->n && _Lt(p->dat()[i].first,key);i++);
		if(i<p->n)now=_Make_it(p,i);
		if(_Leaf(*p))return now;
	}
}
template<class K,__trans=Compare>
const_iterator lower_bound(const K& key)const{
	const _Node *p=_Root;auto now=_Make_cit(nullptr,0);
	for(short i;;p=p->ch[i]){
		for(i=0;i<p->n && _Lt(p->dat()[i].first,key);i++);
		if(i<p->n)now=_Make_cit(p,i);
		if(_Leaf(*p))return now;
	}
}

void _Debug(const _Node* p,int d=0)const{
	printf("%*sNode %p(n=%d):\n",d*4,"",p,p->n);
	for(int i=0;i<=p->n;i++){
		if(p->ch){
			printf("%*sCh #%d: %p\n",d*4+2,"",i,p->ch[i]);
			_Debug(p->ch[i],d+1);
		}
		if(i<p->n)
			printf("%*sDat #%d: %d %d\n",d*4+2,"",i,p->dat()[i].first,p->dat()[i].second);
	}
}
void _Debug()const{_Debug(_Root);}

};

}

#endif
